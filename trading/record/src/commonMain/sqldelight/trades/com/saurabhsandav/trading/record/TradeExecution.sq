import com.saurabhsandav.trading.broker.BrokerId;
import com.saurabhsandav.trading.core.Instrument;
import com.saurabhsandav.trading.core.SymbolId;
import com.saurabhsandav.trading.record.model.TradeExecutionId;
import com.saurabhsandav.trading.record.model.TradeExecutionSide;
import java.math.BigDecimal;
import kotlin.Boolean;
import kotlin.Int;
import kotlin.time.Instant;

CREATE TABLE IF NOT EXISTS TradeExecution (
id INTEGER AS TradeExecutionId NOT NULL PRIMARY KEY,
brokerId TEXT AS BrokerId NOT NULL,
instrument TEXT AS Instrument NOT NULL,
symbolId TEXT AS SymbolId NOT NULL,
quantity TEXT AS BigDecimal NOT NULL,
lots INTEGER AS Int,
side TEXT AS TradeExecutionSide NOT NULL,
price TEXT AS BigDecimal NOT NULL,
timestamp TEXT AS Instant NOT NULL,
locked INTEGER AS Boolean NOT NULL
);

insert:
INSERT OR ROLLBACK
INTO TradeExecution(brokerId, instrument, symbolId, quantity, lots, side, price, timestamp, locked)
VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?);

update:
UPDATE TradeExecution
SET brokerId = ?, instrument = ?, symbolId = ?, quantity = ?, lots = ?, side = ?, price = ?, timestamp = ?
WHERE id = ?;

delete:
DELETE FROM TradeExecution
WHERE id = ?;

lock:
UPDATE TradeExecution
SET locked = TRUE
WHERE id IN ?;

getById:
SELECT *
FROM TradeExecution
WHERE id = ?;

getTodayCount:
SELECT count(*)
FROM TradeExecution
WHERE date(timestamp) = date('now');

getBeforeTodayCount:
SELECT count(*)
FROM TradeExecution
WHERE date(timestamp) != date('now');

getAllCount:
SELECT count(*)
FROM TradeExecution;

getBySymbolInInterval:
SELECT *
FROM TradeExecution
WHERE symbolId = :symbolId
AND datetime(:from) < datetime(timestamp)
AND datetime(timestamp) < datetime(:to);

isLocked:
SELECT id, locked
FROM TradeExecution
WHERE id IN ?;
