import com.saurabhsandav.kbigdecimal.KBigDecimal;
import com.saurabhsandav.trading.broker.BrokerId;
import com.saurabhsandav.trading.core.Instrument;
import com.saurabhsandav.trading.core.SymbolId;
import com.saurabhsandav.trading.record.model.TradeExecutionId;
import com.saurabhsandav.trading.record.model.TradeExecutionSide;
import kotlin.Boolean;
import kotlin.Int;
import kotlin.time.Instant;

CREATE TABLE IF NOT EXISTS TradeExecution (
id INTEGER AS TradeExecutionId NOT NULL PRIMARY KEY,
brokerId TEXT AS BrokerId NOT NULL,
symbolId TEXT AS SymbolId NOT NULL,
instrument TEXT AS Instrument NOT NULL,
quantity TEXT AS KBigDecimal NOT NULL,
lots INTEGER AS Int NOT NULL,
side TEXT AS TradeExecutionSide NOT NULL,
price TEXT AS KBigDecimal NOT NULL,
timestamp TEXT AS Instant NOT NULL,
locked INTEGER AS Boolean NOT NULL
);

insert:
INSERT OR ROLLBACK
INTO TradeExecution(brokerId, instrument, symbolId, quantity, lots, side, price, timestamp, locked)
VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
RETURNING id;

update:
UPDATE TradeExecution
SET brokerId = ?, instrument = ?, symbolId = ?, quantity = ?, lots = ?, side = ?, price = ?, timestamp = ?
WHERE id = ?;

delete:
DELETE FROM TradeExecution
WHERE id = ?;

lock:
UPDATE TradeExecution
SET locked = TRUE
WHERE id IN ?;

getById:
SELECT *
FROM TradeExecution
WHERE id = ?;

getTodayCount:
SELECT count(*)
FROM TradeExecution
WHERE date(timestamp) = date('now');

getBeforeTodayCount:
SELECT count(*)
FROM TradeExecution
WHERE date(timestamp) != date('now');

getAllCount:
SELECT count(*)
FROM TradeExecution;

getBySymbolInInterval:
SELECT *
FROM TradeExecution
WHERE symbolId = :symbolId
AND datetime(:from) < datetime(timestamp)
AND datetime(timestamp) < datetime(:to);

isLocked:
SELECT id, locked
FROM TradeExecution
WHERE id IN ?;
