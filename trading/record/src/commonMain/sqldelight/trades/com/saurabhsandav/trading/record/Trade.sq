import com.saurabhsandav.kbigdecimal.KBigDecimal;
import com.saurabhsandav.trading.broker.BrokerId;
import com.saurabhsandav.trading.core.Instrument;
import com.saurabhsandav.trading.core.SymbolId;
import com.saurabhsandav.trading.record.model.TradeId;
import com.saurabhsandav.trading.record.model.TradeSide;
import kotlin.Boolean;
import kotlin.Int;
import kotlin.time.Instant;

CREATE TABLE IF NOT EXISTS Trade (
id INTEGER AS TradeId NOT NULL PRIMARY KEY,
brokerId TEXT AS BrokerId NOT NULL,
symbolId TEXT AS SymbolId NOT NULL,
instrument TEXT AS Instrument NOT NULL,
quantity TEXT AS KBigDecimal NOT NULL,
closedQuantity TEXT AS KBigDecimal NOT NULL,
lots INTEGER AS Int NOT NULL,
closedLots INTEGER AS Int NOT NULL,
side TEXT AS TradeSide NOT NULL,
averageEntry TEXT AS KBigDecimal NOT NULL,
entryTimestamp TEXT AS Instant NOT NULL,
averageExit TEXT AS KBigDecimal,
exitTimestamp TEXT AS Instant,
pnl TEXT AS KBigDecimal NOT NULL,
fees TEXT AS KBigDecimal NOT NULL,
netPnl TEXT AS KBigDecimal NOT NULL,
isClosed INTEGER AS Boolean NOT NULL
);

insert:
INSERT OR ROLLBACK
INTO Trade(id, brokerId, symbolId, instrument, quantity, closedQuantity, lots, closedLots, side, averageEntry,
entryTimestamp, averageExit, exitTimestamp, pnl, fees, netPnl, isClosed)
VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?,?, ?, ?, ?, ?, ?)
RETURNING id;

update:
UPDATE Trade
SET quantity = ?, closedQuantity = ?, lots = ?, closedLots = ?, side = ?, averageEntry = ?, entryTimestamp = ?,
averageExit = ?, exitTimestamp = ?, pnl = ?, fees = ?, netPnl = ?, isClosed = ?
WHERE id = ?;

delete:
DELETE FROM Trade
WHERE id = ?;

exists:
SELECT EXISTS(SELECT * FROM Trade WHERE id = ?);

getExistingIds:
SELECT id FROM Trade WHERE id IN ?;

getAll:
SELECT *
FROM Trade
ORDER BY datetime(entryTimestamp) DESC, id DESC;

getById:
SELECT *
FROM Trade
WHERE id = ?;

getFilteredCount:
WITH ids_with_notes AS (
  SELECT DISTINCT tradeId FROM TradeNote
),
ids_with_tags AS (
  SELECT tradeId
  FROM TradeToTagMap
  WHERE tagId IN :tags
  GROUP BY tradeId
  HAVING :tagsCount = -1 OR COUNT(*) = :tagsCount
)
SELECT count(*)
FROM Trade
WHERE
(:isClosed IS NULL OR isClosed = :isClosed)
AND (:side IS NULL OR side = :side)
AND (:from IS NULL OR datetime(:from) <= datetime(entryTimestamp))
AND (:to IS NULL OR datetime(entryTimestamp) <= datetime(:to))
AND (:timeFrom IS NULL OR time(:timeFrom) <= time(entryTimestamp))
AND (:timeTo IS NULL OR time(entryTimestamp) <= time(:timeTo))
AND (:pnlFrom IS NULL OR :pnlFrom <= CAST(IIF(:filterByNetPnl = TRUE, netPnl, pnl) AS REAL))
AND (:pnlTo IS NULL OR CAST(IIF(:filterByNetPnl = TRUE, netPnl, pnl) AS REAL) <= :pnlTo)
AND (:hasNotes IS NULL OR IIF(:hasNotes = TRUE, id IN ids_with_notes, id NOT IN ids_with_notes))
--  :tagsCount = null -> Disable filter
--  :tagsCount = -1 -> Match some tags
--  :tagsCount >= 0 -> Match all tags
AND (:tagsCount IS NULL OR id IN ids_with_tags)
AND (:symbolsCount <= 0 OR symbolId IN :symbolIds);

getFiltered:
WITH ids_with_notes AS (
  SELECT DISTINCT tradeId FROM TradeNote
),
ids_with_tags AS (
  SELECT tradeId
  FROM TradeToTagMap
  WHERE tagId IN :tags
  GROUP BY tradeId
  HAVING :tagsCount = -1 OR COUNT(*) = :tagsCount
)
SELECT *
FROM Trade
WHERE
(:isClosed IS NULL OR isClosed = :isClosed)
AND (:side IS NULL OR side = :side)
AND (:from IS NULL OR datetime(:from) <= datetime(entryTimestamp))
AND (:to IS NULL OR datetime(entryTimestamp) <= datetime(:to))
AND (:timeFrom IS NULL OR time(:timeFrom) <= time(entryTimestamp))
AND (:timeTo IS NULL OR time(entryTimestamp) <= time(:timeTo))
AND (:pnlFrom IS NULL OR :pnlFrom <= CAST(IIF(:filterByNetPnl = TRUE, netPnl, pnl) AS REAL))
AND (:pnlTo IS NULL OR CAST(IIF(:filterByNetPnl = TRUE, netPnl, pnl) AS REAL) <= :pnlTo)
AND (:hasNotes IS NULL OR IIF(:hasNotes = TRUE, id IN ids_with_notes, id NOT IN ids_with_notes))
--  :tagsCount = null -> Disable filter
--  :tagsCount = -1 -> Match some tags
--  :tagsCount >= 0 -> Match all tags
AND (:tagsCount IS NULL OR id IN ids_with_tags)
AND (:symbolsCount <= 0 OR symbolId IN :symbolIds)
ORDER BY
IIF(:sortOpenFirst = TRUE, isClosed, 0) ASC,
datetime(entryTimestamp) DESC, id DESC;

getOpen:
SELECT *
FROM Trade
WHERE isClosed = FALSE
ORDER BY datetime(entryTimestamp) DESC, id DESC;

getTotalAndOpenCount:
SELECT
  COUNT(*) AS totalCount,
  COUNT(CASE WHEN isClosed = FALSE THEN 1 END) AS openCount
FROM Trade;

getBySymbolInInterval:
SELECT *
FROM Trade
WHERE symbolId = :symbolId
AND datetime(:from) < datetime(entryTimestamp)
AND datetime(entryTimestamp) < datetime(:to);

getBySymbolAndIdsInInterval:
SELECT *
FROM Trade
WHERE symbolId = :symbolId
AND id IN :ids
AND datetime(:from) < datetime(entryTimestamp)
AND datetime(entryTimestamp) < datetime(:to);

getWithoutExcursionsBeforeTimestamp:
SELECT Trade.*
FROM Trade
LEFT JOIN TradeExcursions
ON Trade.id = TradeExcursions.tradeId
WHERE TradeExcursions.tradeId IS NULL
AND Trade.isClosed = TRUE
AND Trade.entryTimestamp < ?;

getSuggestedSymbols:
SELECT DISTINCT symbolId
FROM Trade
WHERE
symbolId NOT IN :ignore
AND symbolId LIKE '%' || :query || '%';
