import com.saurabhsandav.kbigdecimal.KBigDecimal;
import com.saurabhsandav.trading.record.model.TradeExecutionId;
import com.saurabhsandav.trading.record.model.TradeId;
import kotlin.Int;

CREATE TABLE IF NOT EXISTS TradeToExecutionMap (
tradeId INTEGER AS TradeId NOT NULL,
executionId INTEGER AS TradeExecutionId NOT NULL,
overrideQuantity TEXT AS KBigDecimal,
overrideLots INTEGER AS Int,
FOREIGN KEY(tradeId) REFERENCES Trade(id) ON DELETE CASCADE,
FOREIGN KEY(executionId) REFERENCES TradeExecution(id) ON DELETE CASCADE,
PRIMARY KEY (tradeId, executionId)
);

insert:
INSERT OR IGNORE INTO TradeToExecutionMap
VALUES (?, ?, ?, ?);

getExecutionsByTrade:
SELECT
  TradeExecution.*,
  IFNULL(overrideQuantity, TradeExecution.quantity) AS overrideQuantity,
  IFNULL(overrideLots, TradeExecution.lots) AS overrideLots
FROM TradeToExecutionMap
INNER JOIN TradeExecution
ON TradeToExecutionMap.executionId = TradeExecution.id
WHERE TradeToExecutionMap.tradeId = ?
ORDER BY TradeExecution.timestamp ASC;

deleteExecutionsAndTrades {
  DELETE FROM TradeExecution
  WHERE id IN (
    SELECT te.id FROM TradeToExecutionMap ttem
    INNER JOIN TradeExecution te
    ON ttem.executionId = te.id
    WHERE ttem.tradeId IN :tradeIds
  );

  DELETE FROM Trade
  WHERE id IN :tradeIds;
}

getExecutionsBySymbolAndTradeIdsInInterval:
SELECT
  TradeExecution.*,
  IFNULL(overrideQuantity, TradeExecution.quantity) AS overrideQuantity,
  IFNULL(overrideLots, TradeExecution.lots) AS overrideLots
FROM TradeToExecutionMap
INNER JOIN TradeExecution
ON TradeToExecutionMap.executionId = TradeExecution.id
WHERE TradeExecution.symbolId = :symbolId
AND TradeToExecutionMap.tradeId IN :ids
AND datetime(:from) < datetime(TradeExecution.timestamp)
AND datetime(TradeExecution.timestamp) < datetime(:to)
ORDER BY TradeExecution.timestamp ASC;

getTradesByExecution:
SELECT Trade.* FROM TradeToExecutionMap
INNER JOIN Trade
ON TradeToExecutionMap.tradeId = Trade.id
WHERE TradeToExecutionMap.executionId = ?;
