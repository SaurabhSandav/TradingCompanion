import com.saurabhsandav.core.trades.model.TradeId;
import java.math.BigDecimal;
import kotlin.Boolean;

CREATE TABLE IF NOT EXISTS TradeTarget (
tradeId INTEGER AS TradeId NOT NULL,
price TEXT AS BigDecimal NOT NULL,
isPrimary INTEGER AS Boolean NOT NULL DEFAULT FALSE,
FOREIGN KEY(tradeId) REFERENCES Trade(id) ON DELETE CASCADE,
PRIMARY KEY (tradeId, price)
);

insert:
WITH is_primary AS (
  SELECT NOT EXISTS(SELECT * FROM TradeTarget WHERE tradeId = :tradeId AND isPrimary = TRUE)
)
INSERT OR IGNORE
INTO TradeTarget(tradeId, price, isPrimary)
VALUES (:tradeId, ?, (SELECT * FROM is_primary));

getByTrade:
SELECT *
FROM TradeTarget
WHERE tradeId = ?
ORDER BY rowid ASC;

getPrimaryTargetByTrade:
SELECT *
FROM TradeTarget
WHERE tradeId = ? AND isPrimary = TRUE;

getPrimaryTargetsByTrades:
SELECT *
FROM TradeTarget
WHERE tradeId IN ?
GROUP BY tradeId
HAVING isPrimary = TRUE;

delete {

DELETE FROM TradeTarget
WHERE tradeId = :tradeId AND price = ?;

-- If deleted target was primary, set farthest price as new primary
WITH new_primary AS (
  SELECT TradeTarget.* FROM TradeTarget
  INNER JOIN Trade ON TradeTarget.tradeId = Trade.id
  WHERE tradeId = :tradeId
  ORDER BY
    isPrimary DESC,
    ABS(CAST(Trade.averageEntry AS REAL) - CAST(TradeTarget.price AS REAL)) DESC
  LIMIT 1
)
UPDATE TradeTarget
SET isPrimary = (SELECT EXISTS(SELECT * FROM new_primary WHERE price = TradeTarget.price))
WHERE tradeId = :tradeId;
}

deleteByTrade:
DELETE FROM TradeTarget
WHERE tradeId = ?;

setPrimary {
  UPDATE TradeTarget
  SET isPrimary = FALSE
  WHERE tradeId = :tradeId;

  UPDATE TradeTarget
  SET isPrimary = TRUE
  WHERE
    tradeId = :tradeId
    AND price = ?;
}
