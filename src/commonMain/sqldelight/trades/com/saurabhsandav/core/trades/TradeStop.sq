import com.saurabhsandav.core.trades.model.TradeId;
import java.math.BigDecimal;
import kotlin.Boolean;

CREATE TABLE IF NOT EXISTS TradeStop (
tradeId INTEGER AS TradeId NOT NULL,
price TEXT AS BigDecimal NOT NULL,
isPrimary INTEGER AS Boolean NOT NULL DEFAULT FALSE,
FOREIGN KEY(tradeId) REFERENCES Trade(id) ON DELETE CASCADE,
PRIMARY KEY (tradeId, price)
);

insert:
WITH is_primary AS (
  SELECT NOT EXISTS(SELECT * FROM TradeStop WHERE tradeId = :tradeId AND isPrimary = TRUE)
)
INSERT OR IGNORE
INTO TradeStop(tradeId, price, isPrimary)
VALUES (:tradeId, ?, (SELECT * FROM is_primary));

delete {

  DELETE FROM TradeStop
  WHERE tradeId = :tradeId AND price = ?;

  -- If deleted stop was primary, set closest price as new primary
  WITH new_primary AS (
    SELECT TradeStop.* FROM TradeStop
    INNER JOIN Trade ON TradeStop.tradeId = Trade.id
    WHERE tradeId = :tradeId
    ORDER BY
      isPrimary DESC,
      ABS(CAST(Trade.averageEntry AS REAL) - CAST(TradeStop.price AS REAL)) ASC
    LIMIT 1
  )
  UPDATE TradeStop
  SET isPrimary = (SELECT EXISTS(SELECT * FROM new_primary WHERE price = TradeStop.price))
  WHERE tradeId = :tradeId;
}

deleteByTrade:
DELETE FROM TradeStop
WHERE tradeId = ?;

setPrimary {
  UPDATE TradeStop
  SET isPrimary = FALSE
  WHERE tradeId = :tradeId;

  UPDATE TradeStop
  SET isPrimary = TRUE
  WHERE
    tradeId = :tradeId
    AND price = ?;
}

getByTrade:
SELECT *
FROM TradeStop
WHERE tradeId = ?
ORDER BY rowid ASC;

getPrimaryStopByTrade:
SELECT *
FROM TradeStop
WHERE tradeId = ? AND isPrimary = TRUE;

getPrimaryStopsByTrades:
SELECT *
FROM TradeStop
WHERE tradeId IN ?
GROUP BY tradeId
HAVING isPrimary = TRUE;
