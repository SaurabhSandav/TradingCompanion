import com.saurabhsandav.core.trades.model.Instrument;
import com.saurabhsandav.core.trades.model.TradeId;
import com.saurabhsandav.core.trades.model.TradeSide;
import java.math.BigDecimal;
import kotlin.Boolean;
import kotlin.Int;
import kotlinx.datetime.Instant;

CREATE TABLE IF NOT EXISTS Trade (
id INTEGER AS TradeId NOT NULL PRIMARY KEY,
broker TEXT NOT NULL,
ticker TEXT NOT NULL,
instrument TEXT AS Instrument NOT NULL,
quantity TEXT AS BigDecimal NOT NULL,
closedQuantity TEXT AS BigDecimal NOT NULL,
lots INTEGER AS Int,
side TEXT AS TradeSide NOT NULL,
averageEntry TEXT AS BigDecimal NOT NULL,
entryTimestamp TEXT AS Instant NOT NULL,
averageExit TEXT AS BigDecimal,
exitTimestamp TEXT AS Instant,
pnl TEXT AS BigDecimal NOT NULL,
fees TEXT AS BigDecimal NOT NULL,
netPnl TEXT AS BigDecimal NOT NULL,
isClosed INTEGER AS Boolean NOT NULL
);

insert:
INSERT OR ROLLBACK
INTO Trade(broker, ticker, instrument, quantity, closedQuantity, lots, side, averageEntry, entryTimestamp,
averageExit, exitTimestamp, pnl, fees, netPnl, isClosed)
VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?,
?, ?, ?, ?, ?, ?);

update:
UPDATE Trade
SET quantity = ?, closedQuantity = ?, lots = ?, side = ?, averageEntry = ?, entryTimestamp = ?, averageExit = ?,
exitTimestamp = ?, pnl = ?, fees = ?, netPnl = ?, isClosed = ?
WHERE id = ?;

exists:
SELECT EXISTS(SELECT * FROM Trade WHERE id = ?);

getExistingIds:
SELECT id FROM Trade WHERE id IN ?;

getAll:
SELECT *
FROM Trade
ORDER BY datetime(entryTimestamp) DESC, id DESC;

getById:
SELECT *
FROM Trade
WHERE id = ?;

getByIds:
SELECT *
FROM Trade
WHERE id IN ?
ORDER BY datetime(entryTimestamp) DESC, id DESC;

getFiltered:
WITH ids_with_notes AS (
  SELECT DISTINCT tradeId FROM TradeNote
),
ids_with_tags AS (
  SELECT tradeId
  FROM TradeToTagMap
  WHERE tagId IN :tags
  GROUP BY tradeId
  HAVING :tagsCount = -1 OR COUNT(*) = :tagsCount
)
SELECT *
FROM Trade
WHERE
(:isClosed IS NULL OR isClosed = :isClosed)
AND (:side IS NULL OR side = :side)
AND (:from IS NULL OR datetime(:from) <= datetime(entryTimestamp))
AND (:to IS NULL OR datetime(entryTimestamp) <= datetime(:to))
AND (:timeFrom IS NULL OR time(:timeFrom) <= time(entryTimestamp))
AND (:timeTo IS NULL OR time(entryTimestamp) <= time(:timeTo))
AND (:pnlFrom IS NULL OR :pnlFrom <= CAST(IIF(:filterByNetPnl = TRUE, netPnl, pnl) AS REAL))
AND (:pnlTo IS NULL OR CAST(IIF(:filterByNetPnl = TRUE, netPnl, pnl) AS REAL) <= :pnlTo)
AND (:hasNotes IS NULL OR IIF(:hasNotes = TRUE, id IN ids_with_notes, id NOT IN ids_with_notes))
--  :tagsCount = null -> Disable filter
--  :tagsCount = -1 -> Match some tags
--  :tagsCount >= 0 -> Match all tags
AND (:tagsCount IS NULL OR id IN ids_with_tags)
AND (:tickersCount <= 0 OR ticker IN :tickers)
ORDER BY
IIF(:sortOpenFirst = TRUE, isClosed, 0) ASC,
datetime(entryTimestamp) DESC, id DESC;

getOpen:
SELECT *
FROM Trade
WHERE isClosed = FALSE
ORDER BY datetime(entryTimestamp) DESC, id DESC;

getTotalAndOpenCount:
SELECT
  COUNT(*) AS totalCount,
  COUNT(CASE WHEN isClosed = FALSE THEN 1 END) AS openCount
FROM Trade;

getByTickerInInterval:
SELECT *
FROM Trade
WHERE ticker = :ticker
AND datetime(:from) < datetime(entryTimestamp)
AND datetime(entryTimestamp) < datetime(:to);

getByTickerAndIdsInInterval:
SELECT *
FROM Trade
WHERE ticker = :ticker
AND id IN :ids
AND datetime(:from) < datetime(entryTimestamp)
AND datetime(entryTimestamp) < datetime(:to);

getWithoutExcursionsBeforeTimestamp:
SELECT Trade.*
FROM Trade
LEFT JOIN TradeExcursions
ON Trade.id = TradeExcursions.tradeId
WHERE TradeExcursions.tradeId IS NULL
AND Trade.isClosed = TRUE
AND Trade.entryTimestamp < ?;

getSuggestedTickers:
SELECT DISTINCT ticker
FROM Trade
WHERE
ticker NOT IN :ignore
AND ticker LIKE '%' || :query || '%';

delete:
DELETE FROM Trade
WHERE id = ?;
