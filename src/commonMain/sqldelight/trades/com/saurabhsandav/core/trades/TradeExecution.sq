import com.saurabhsandav.core.trades.model.Instrument;
import com.saurabhsandav.core.trades.model.TradeExecutionId;
import com.saurabhsandav.core.trades.model.TradeExecutionSide;
import java.math.BigDecimal;
import kotlin.Boolean;
import kotlin.Int;
import kotlinx.datetime.Instant;

CREATE TABLE IF NOT EXISTS TradeExecution (
id INTEGER AS TradeExecutionId NOT NULL PRIMARY KEY,
broker TEXT NOT NULL,
instrument TEXT AS Instrument NOT NULL,
ticker TEXT NOT NULL,
quantity TEXT AS BigDecimal NOT NULL,
lots INTEGER AS Int,
side TEXT AS TradeExecutionSide NOT NULL,
price TEXT AS BigDecimal NOT NULL,
timestamp TEXT AS Instant NOT NULL,
locked INTEGER AS Boolean NOT NULL
);

insert:
INSERT OR ROLLBACK
INTO TradeExecution(broker, instrument, ticker, quantity, lots, side, price, timestamp, locked)
VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?);

update:
UPDATE TradeExecution
SET broker = ?, instrument = ?, ticker = ?, quantity = ?, lots = ?, side = ?, price = ?, timestamp = ?
WHERE id = ?;

getAll:
SELECT *
FROM TradeExecution
ORDER BY date(timestamp) DESC, time(timestamp) DESC;

getById:
SELECT *
FROM TradeExecution
WHERE id = ?;

getToday:
SELECT *
FROM TradeExecution
WHERE date(timestamp) = date('now')
ORDER BY datetime(timestamp) DESC;

getBeforeToday:
SELECT *
FROM TradeExecution
WHERE date(timestamp) != date('now')
ORDER BY datetime(timestamp) DESC;

getByTickerInInterval:
SELECT *
FROM TradeExecution
WHERE ticker = :ticker
AND datetime(:from) < datetime(timestamp)
AND datetime(timestamp) < datetime(:to);

isLocked:
SELECT id, locked
FROM TradeExecution
WHERE id IN ?;

lock:
UPDATE TradeExecution
SET locked = TRUE
WHERE id IN ?;

delete:
DELETE FROM TradeExecution
WHERE id = ?;
