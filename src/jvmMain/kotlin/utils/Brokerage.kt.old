package utils

import Side
import java.math.BigDecimal
import java.math.RoundingMode
import java.util.*

internal fun brokerage(
    broker: String,
    instrument: String,
    entry: BigDecimal,
    exit: BigDecimal,
    quantity: BigDecimal,
    side: Side,
): BigDecimal = when (broker.lowercase(Locale.getDefault())) {
    "zerodha" -> zerodhaBrokerage(instrument, entry, exit, quantity, side)
    "finvasia" -> finvasiaBrokerage(instrument, entry, exit, quantity, side)
    else -> error("Invalid broker")
}

private fun zerodhaBrokerage(
    instrument: String,
    entry: BigDecimal,
    exit: BigDecimal,
    quantity: BigDecimal,
    side: Side,
): BigDecimal {

    val (sttMultiplier, excTransChargeMultiplier) = when(instrument.lowercase()) {
        "equity" -> "0.00025".toBigDecimal() to "0.0000345".toBigDecimal()
        "futures" -> "0.0001".toBigDecimal() to "0.00002".toBigDecimal()
        "options" -> "0.0005".toBigDecimal() to "0.00053".toBigDecimal()
        else -> error("Invalid instrument: $instrument")
    }

    val (buyPrice, sellPrice) = when(side) {
        Side.Long -> entry to exit
        Side.Short -> exit to entry
    }

    val buyTurnover = (buyPrice * quantity).setScale(2, RoundingMode.HALF_EVEN)
    val sellTurnover = (sellPrice * quantity).setScale(2, RoundingMode.HALF_EVEN)

    val brokerageBuy = when {
        (buyTurnover * "0.0003".toBigDecimal()) > "20".toBigDecimal() -> "20".toBigDecimal()
        else -> (buyTurnover * "0.0003".toBigDecimal())
    }
    val brokerageSell = when {
        (sellTurnover * "0.0003".toBigDecimal()) > "20".toBigDecimal() -> "20".toBigDecimal()
        else -> (sellTurnover * "0.0003".toBigDecimal())
    }
    val brokerage = brokerageBuy + brokerageSell

    val turnover = (buyTurnover + sellTurnover).setScale(2, RoundingMode.HALF_EVEN)

    val sttTotal = (sellTurnover * sttMultiplier).setScale(0, RoundingMode.HALF_EVEN)

    val excTransCharge = (excTransChargeMultiplier * turnover).setScale(2, RoundingMode.HALF_EVEN)

    val sebiCharges = (turnover * "0.000001".toBigDecimal()).setScale(2, RoundingMode.HALF_EVEN)

    val stax = ("0.18".toBigDecimal() * (brokerage + excTransCharge + sebiCharges)).setScale(2, RoundingMode.HALF_EVEN)

    val stampCharges = (buyTurnover * "0.00003".toBigDecimal()).setScale(0, RoundingMode.HALF_EVEN)

    val totalCharges = brokerage + sttTotal + excTransCharge + stax + sebiCharges + stampCharges

    val netProfit = (sellTurnover - buyTurnover - totalCharges).setScale(2, RoundingMode.HALF_EVEN)

    return netProfit
}

private fun finvasiaBrokerage(
    instrument: String,
    entry: BigDecimal,
    exit: BigDecimal,
    quantity: BigDecimal,
    side: Side,
): BigDecimal {

    val (sttMultiplier, excTransChargeMultiplier) = when(instrument.lowercase()) {
        "equity" -> "0.00025".toBigDecimal() to "0.0000345".toBigDecimal()
        "futures" -> "0.0001".toBigDecimal() to "0.00002".toBigDecimal()
        "options" -> "0.0005".toBigDecimal() to "0.00053".toBigDecimal()
        else -> error("Invalid instrument: $instrument")
    }

    val (buyPrice, sellPrice) = when(side) {
        Side.Long -> entry to exit
        Side.Short -> exit to entry
    }

    val buyTurnover = (buyPrice * quantity).setScale(2, RoundingMode.HALF_EVEN)
    val sellTurnover = (sellPrice * quantity).setScale(2, RoundingMode.HALF_EVEN)

    val turnover = (buyTurnover + sellTurnover).setScale(2, RoundingMode.HALF_EVEN)

    val sttTotal = (sellTurnover * sttMultiplier).setScale(0, RoundingMode.HALF_EVEN)

    val excTransCharge = (excTransChargeMultiplier * turnover).setScale(2, RoundingMode.HALF_EVEN)

    val sebiCharges = (turnover * "0.000001".toBigDecimal()).setScale(2, RoundingMode.HALF_EVEN)

    val stax = ("0.18".toBigDecimal() * (excTransCharge + sebiCharges)).setScale(2, RoundingMode.HALF_EVEN)

    val stampCharges = (buyTurnover * "0.00003".toBigDecimal()).setScale(0, RoundingMode.HALF_EVEN)

    val totalCharges = sttTotal + excTransCharge + stax + sebiCharges + stampCharges

    val netProfit = (sellTurnover - buyTurnover - totalCharges).setScale(2, RoundingMode.HALF_EVEN)

    return netProfit
}

/**
 * You can edit, run, and share this code.
 * play.kotlinlang.org
 */
/*
* import java.math.BigDecimal
import java.math.RoundingMode
import java.math.MathContext

/**
 * You can edit, run, and share this code.
 * play.kotlinlang.org
 */
fun main() {

//     brokerage("1231".toBigDecimal(), "1225.3".toBigDecimal(), "24".toBigDecimal(), "Short")

//     brokerage("233.45".toBigDecimal(), "233.6".toBigDecimal(), "238".toBigDecimal(), "Long")

     brokerage("936.15".toBigDecimal(), "937.75".toBigDecimal(), "76".toBigDecimal(), "Short")
     brokerage("583.35".toBigDecimal(), "582".toBigDecimal(), "96".toBigDecimal(), "Long")
     brokerage("553.4".toBigDecimal(), "551.25".toBigDecimal(), "102".toBigDecimal(), "Long")
}

fun brokerage(
    entry: BigDecimal,
    exit: BigDecimal,
    quantity: BigDecimal,
    side: String,
) {

        val instrument = "equity"

    val sttMultiplier = when(instrument) {
        "equity" -> "0.00025"
        "futures" -> "0.0001"
        "options" -> "0.0005"
        else -> error("Invalid instrument: ${instrument}")
    }.toBigDecimal()

    val excTransChargeMultiplier = when(instrument) {
        "equity" -> "0.0000345"
        "futures" -> "0.00002"
        "options" -> "0.00053"
        else -> error("Invalid instrument: ${instrument}")
    }.toBigDecimal()

    val bp = when(side) {
        "Long" ->  entry
        else -> exit
    }
    val sp = when(side) {
        "Long" ->  exit
        else -> entry
    }

    val turnover = ((bp + sp) * quantity).setScale(2, RoundingMode.HALF_EVEN)

    val sttTotal = ((sp * quantity) * sttMultiplier).setScale(0, RoundingMode.HALF_EVEN)

    val excTransCharge = (excTransChargeMultiplier * turnover).setScale(2, RoundingMode.HALF_EVEN)

    val sebiCharges = (turnover * "0.000001".toBigDecimal()).setScale(2, RoundingMode.HALF_EVEN)

    val stax = ("0.18".toBigDecimal() * (sebiCharges + excTransCharge)).setScale(2, RoundingMode.HALF_EVEN)

    val stampCharges = ((bp * quantity) * "0.00003".toBigDecimal()).setScale(0, RoundingMode.HALF_EVEN)

    val totalTax = sttTotal + excTransCharge + stax + sebiCharges + stampCharges

    val netProfit = (((sp - bp) * quantity) - totalTax).setScale(2, RoundingMode.HALF_EVEN)

    println("Turnover: $turnover")
    println("STT: $sttTotal")
    println("EXCTRNCHRG: $excTransCharge")
    println("STAX: $stax")
    println("SEBICHGS: $sebiCharges")
    println("STAMP: $stampCharges")
    println("TOTALTAX: $totalTax")
    println("Profit: $netProfit")
    println("--------------------------------")
}

fun BigDecimal.round(
    increment: BigDecimal,
    roundingMode: RoundingMode?,
): BigDecimal {
    return if (increment.signum() == 0) {
        // 0 increment does not make much sense, but prevent division by 0
        this
    } else {
        val divided = divide(increment, 0, roundingMode)
        divided.multiply(increment)
    }
}
*
* */
