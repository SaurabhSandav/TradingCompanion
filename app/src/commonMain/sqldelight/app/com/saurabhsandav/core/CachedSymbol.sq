import com.saurabhsandav.kbigdecimal.KBigDecimal;
import com.saurabhsandav.trading.broker.BrokerId;
import com.saurabhsandav.trading.broker.OptionType;
import com.saurabhsandav.trading.core.Instrument;
import com.saurabhsandav.trading.core.SymbolId;
import kotlin.time.Instant;

CREATE TABLE IF NOT EXISTS CachedSymbol (
id TEXT AS SymbolId NOT NULL,
brokerId TEXT AS BrokerId NOT NULL,
exchange TEXT NOT NULL,
exchangeToken TEXT NOT NULL,
instrument TEXT AS Instrument NOT NULL,
ticker TEXT NOT NULL,
tickSize TEXT AS KBigDecimal NOT NULL,
lotSize TEXT AS KBigDecimal NOT NULL,
description TEXT,
expiry TEXT AS Instant,
strikePrice TEXT AS KBigDecimal,
optionType TEXT AS OptionType,
lastUpdate TEXT AS Instant NOT NULL DEFAULT '1970-01-01T00:00:00Z',
PRIMARY KEY (id, brokerId)
);

insert:
INSERT OR REPLACE
INTO CachedSymbol(id, brokerId, exchange, exchangeToken, instrument, ticker, tickSize, lotSize, description, expiry,
strikePrice, optionType, lastUpdate)
VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?);

getAll:
SELECT * FROM CachedSymbol;

get:
SELECT * FROM CachedSymbol
WHERE id = ? AND brokerId = ?;

getFilteredCount:
SELECT COUNT(*)
FROM CachedSymbol AS T1
INNER JOIN CachedSymbol_fts AS T2 ON T1.rowid = T2.rowid
WHERE
T2.CachedSymbol_fts MATCH :filterQuery
AND (:instrumentsCount <= 0 OR instrument IN :instruments)
AND (:exchange IS NULL OR exchange = :exchange)
AND lastUpdate >= :lastUpdate;

getFiltered:
SELECT T1.*
FROM CachedSymbol AS T1
INNER JOIN CachedSymbol_fts AS T2 ON T1.rowid = T2.rowid
WHERE
T2.CachedSymbol_fts MATCH :filterQuery
AND (:instrumentsCount <= 0 OR instrument IN :instruments)
AND (:exchange IS NULL OR exchange = :exchange)
AND lastUpdate >= :lastUpdate
ORDER BY T1.ticker, T1.instrument
LIMIT :limit OFFSET :offset;
