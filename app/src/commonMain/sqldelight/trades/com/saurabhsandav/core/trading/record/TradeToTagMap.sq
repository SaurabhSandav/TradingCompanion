import com.saurabhsandav.core.trading.record.model.TradeId;
import com.saurabhsandav.core.trading.record.model.TradeTagId;

CREATE TABLE IF NOT EXISTS TradeToTagMap (
tradeId INTEGER AS TradeId NOT NULL,
tagId INTEGER AS TradeTagId NOT NULL,
FOREIGN KEY(tradeId) REFERENCES Trade(id) ON DELETE CASCADE,
FOREIGN KEY(tagId) REFERENCES TradeTag(id) ON DELETE CASCADE,
PRIMARY KEY (tradeId, tagId)
);

insert:
INSERT OR IGNORE INTO TradeToTagMap(tradeId, tagId)
VALUES (?, ?);

delete:
DELETE FROM TradeToTagMap
WHERE tradeId = ? AND tagId = ?;

getTagsByTrade:
SELECT TradeTag.* FROM TradeToTagMap
INNER JOIN TradeTag
ON TradeToTagMap.tagId = TradeTag.id
WHERE TradeToTagMap.tradeId = ?;

getSuggestedTagsForTrades:
WITH trade_count AS (
  SELECT COUNT(DISTINCT id) FROM Trade WHERE id IN :tradeIds
),
tag_ids_intersection AS (
  SELECT ttm.tagId
  FROM TradeToTagMap AS ttm
  WHERE ttm.tradeId IN :tradeIds
  GROUP BY ttm.tagId
  HAVING COUNT(DISTINCT ttm.tradeId) = (SELECT * FROM trade_count)
)
SELECT tt.*
FROM TradeTag AS tt
WHERE tt.id NOT IN (SELECT * FROM tag_ids_intersection)
AND tt.name LIKE '%' || :filterQuery || '%';

getTradesByTag:
SELECT Trade.* FROM TradeToTagMap
INNER JOIN Trade
ON TradeToTagMap.tradeId = Trade.id
WHERE TradeToTagMap.tagId = ?;
