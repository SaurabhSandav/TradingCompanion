import com.saurabhsandav.core.trades.model.TradeExecutionId;
import com.saurabhsandav.core.trades.model.TradeId;
import java.math.BigDecimal;

CREATE TABLE IF NOT EXISTS TradeToExecutionMap (
tradeId INTEGER AS TradeId NOT NULL,
executionId INTEGER AS TradeExecutionId NOT NULL,
overrideQuantity TEXT AS BigDecimal,
FOREIGN KEY(tradeId) REFERENCES Trade(id) ON DELETE CASCADE,
FOREIGN KEY(executionId) REFERENCES TradeExecution(id) ON DELETE CASCADE,
PRIMARY KEY (tradeId, executionId)
);

insert:
INSERT OR IGNORE INTO TradeToExecutionMap
VALUES (?, ?, ?);

getExecutionsByTrade:
SELECT TradeExecution.*, IFNULL(overrideQuantity, TradeExecution.quantity) AS overrideQuantity FROM TradeToExecutionMap
INNER JOIN TradeExecution
ON TradeToExecutionMap.executionId = TradeExecution.id
WHERE TradeToExecutionMap.tradeId = ?
ORDER BY TradeExecution.timestamp ASC;

deleteExecutionsAndTrades {
  DELETE FROM TradeExecution
  WHERE id IN (
    SELECT te.id FROM TradeToExecutionMap ttem
    INNER JOIN TradeExecution te
    ON ttem.executionId = te.id
    WHERE ttem.tradeId IN :tradeIds
  );

  DELETE FROM Trade
  WHERE id IN :tradeIds;
}

getExecutionsByTickerAndTradeIdsInInterval:
SELECT TradeExecution.*, IFNULL(overrideQuantity, TradeExecution.quantity) AS overrideQuantity FROM TradeToExecutionMap
INNER JOIN TradeExecution
ON TradeToExecutionMap.executionId = TradeExecution.id
WHERE TradeExecution.ticker = :ticker
AND TradeToExecutionMap.tradeId IN :ids
AND datetime(:from) < datetime(TradeExecution.timestamp)
AND datetime(TradeExecution.timestamp) < datetime(:to)
ORDER BY TradeExecution.timestamp ASC;

getTradesByExecution:
SELECT Trade.* FROM TradeToExecutionMap
INNER JOIN Trade
ON TradeToExecutionMap.tradeId = Trade.id
WHERE TradeToExecutionMap.executionId = ?;
