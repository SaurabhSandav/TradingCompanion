import com.saurabhsandav.core.trades.model.TradeExecutionId;
import com.saurabhsandav.core.trades.model.TradeId;
import java.math.BigDecimal;

CREATE TABLE IF NOT EXISTS TradeToExecutionMap (
tradeId INTEGER AS TradeId NOT NULL,
executionId INTEGER AS TradeExecutionId NOT NULL,
overrideQuantity TEXT AS BigDecimal,
FOREIGN KEY(tradeId) REFERENCES Trade(id) ON DELETE CASCADE,
FOREIGN KEY(executionId) REFERENCES TradeExecution(id) ON DELETE CASCADE,
PRIMARY KEY (tradeId, executionId)
);

insert:
INSERT OR IGNORE INTO TradeToExecutionMap
VALUES (?, ?, ?);

getExecutionsByTrade:
SELECT TradeExecution.*, IFNULL(overrideQuantity, TradeExecution.quantity) AS overrideQuantity FROM TradeToExecutionMap
INNER JOIN TradeExecution
ON TradeToExecutionMap.executionId = TradeExecution.id
WHERE TradeToExecutionMap.tradeId = ?
ORDER BY TradeExecution.timestamp ASC;

getExecutionsByTickerAndTradeIdsInInterval:
SELECT TradeExecution.*, IFNULL(overrideQuantity, TradeExecution.quantity) AS overrideQuantity FROM TradeToExecutionMap
INNER JOIN TradeExecution
ON TradeToExecutionMap.executionId = TradeExecution.id
WHERE TradeExecution.ticker = :ticker
AND TradeToExecutionMap.tradeId IN :ids
AND datetime(:from) < datetime(TradeExecution.timestamp)
AND datetime(TradeExecution.timestamp) < datetime(:to)
ORDER BY TradeExecution.timestamp ASC;

getTradesByExecution:
SELECT Trade.* FROM TradeToExecutionMap
INNER JOIN Trade
ON TradeToExecutionMap.tradeId = Trade.id
WHERE TradeToExecutionMap.executionId = ?;
