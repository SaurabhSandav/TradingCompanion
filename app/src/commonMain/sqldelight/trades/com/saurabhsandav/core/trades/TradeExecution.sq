import com.saurabhsandav.core.trades.model.Instrument;
import com.saurabhsandav.core.trades.model.TradeExecutionId;
import com.saurabhsandav.core.trades.model.TradeExecutionSide;
import java.math.BigDecimal;
import kotlin.Boolean;
import kotlin.Int;
import kotlinx.datetime.Instant;

CREATE TABLE IF NOT EXISTS TradeExecution (
id INTEGER AS TradeExecutionId NOT NULL PRIMARY KEY,
broker TEXT NOT NULL,
instrument TEXT AS Instrument NOT NULL,
ticker TEXT NOT NULL,
quantity TEXT AS BigDecimal NOT NULL,
lots INTEGER AS Int,
side TEXT AS TradeExecutionSide NOT NULL,
price TEXT AS BigDecimal NOT NULL,
timestamp TEXT AS Instant NOT NULL,
locked INTEGER AS Boolean NOT NULL
);

insert:
INSERT OR ROLLBACK
INTO TradeExecution(broker, instrument, ticker, quantity, lots, side, price, timestamp, locked)
VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?);

update:
UPDATE TradeExecution
SET broker = ?, instrument = ?, ticker = ?, quantity = ?, lots = ?, side = ?, price = ?, timestamp = ?
WHERE id = ?;

delete:
DELETE FROM TradeExecution
WHERE id = ?;

lock:
UPDATE TradeExecution
SET locked = TRUE
WHERE id IN ?;

getById:
SELECT *
FROM TradeExecution
WHERE id = ?;

getTodayCount:
SELECT count(*)
FROM TradeExecution
WHERE date(timestamp) = date('now');

getBeforeTodayCount:
SELECT count(*)
FROM TradeExecution
WHERE date(timestamp) != date('now');

getAllCount:
SELECT count(*)
FROM TradeExecution;

getAllPaged:
SELECT *
FROM TradeExecution
ORDER BY datetime(timestamp) DESC, id DESC
LIMIT :limit OFFSET :offset;

getByTickerInInterval:
SELECT *
FROM TradeExecution
WHERE ticker = :ticker
AND datetime(:from) < datetime(timestamp)
AND datetime(timestamp) < datetime(:to);

isLocked:
SELECT id, locked
FROM TradeExecution
WHERE id IN ?;
